<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈并发</title>
    <link href="/2020/06/01/%E6%B5%85%E8%B0%88%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/06/01/%E6%B5%85%E8%B0%88%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要讲的是<strong>并发编程在Java中的应用</strong>，由于本人理解有限，所以内容可能在很厉害的人眼里不太有深度，但是本文仅仅限于初学者学习，有一个对与<em>并发</em>学习的开始之端！</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>线程简介</li><li>启动&amp;终止线程</li><li>线程通信</li><li>结束语</li></ul><h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><ul><li><p><strong>什么是线程</strong></p><p>​    线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p></li><li><p><strong>为什么要使用多线程</strong></p><p>​    目前的处理器核心越来越多，使用多线程能有更快的响应时间，并能有更好的编程模型。 </p></li><li><p><strong>线程优先级</strong></p><p>​    现代操作系统基本采用时分的形式调度运行的线程，操作系统分出每一个时间片会根据线程的优先级来分配，优先级越高的最先获取执行资源。</p><p>​    在Java线程中，通过一个整型成员变量<code>priority</code>来控制优先级，优先级的范围从<code>1~10</code>，在线程构建的时候可以通过<code>setPriority(int)</code>方法来修改优先级，默认优先级是<code>5</code>，优先级高的线程分配时间片的数量要多于优先级低的线程。</p></li></ul><ul><li><strong>频繁阻塞</strong>（休眠或者I/O操作）的线程需要设置 <strong>较高优先级</strong>，</li><li><strong>偏重计算</strong>（需要较多CPU时间或者偏运算）的线程则设置 <strong>较低的优先级</strong>，确保处理器不会被独占。</li></ul><p>在不同的 <strong>JVM</strong>以及 <strong>操作系统</strong> 上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</p><p><strong>线程优先级不能作为程序正确性的依赖</strong>，因为操作系统可以完全不用理会 <code>Java</code> 线程对于优先级的设定。</p><ul><li><strong>线程的状态</strong></li></ul><ul><li><code>NEW</code> 初始状态</li><li><code>RUNNABLE</code> 运行状态</li><li><code>BLOCKED</code> 阻塞状态</li><li><code>WAITING</code> 等待状态</li><li><code>TIME_WAITING</code> 超时等待状态</li><li><code>TERMINATED</code> 终止状态</li></ul><p>状态变化：</p><p><img src="F:%5CBlog%5Csource%5Cphotos%5C%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.jpg" srcset="/img/loading.gif" alt="状态变化"></p><ul><li><strong>Daemon线程</strong><pre><code>**Daemon** 线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。   这意味着，**当一个Java虚拟机中不存在非`Daemon`线程的时候，Java虚拟机将会退出**（`Daemon`线程不一定会执行完）。</code></pre> 可以通过调用<code>Thread.setDaemon(true)</code>将线程设置为<code>Daemon</code>线程。需在启动之前设置。</li></ul><h2 id="启动和终止线程"><a href="#启动和终止线程" class="headerlink" title="启动和终止线程"></a>启动和终止线程</h2><p>线程随着 <code>thread.start()</code> 开始启动  到  <code>run()</code> 方法执行完毕 结束。</p><p>我们可以通过 <code>Thread.interrupted()</code> 方法中断线程。</p><blockquote><p>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。<br> 线程通过检查自身是否被中断来进行响应，线程通过方法<code>isInterrupted()</code>来进行判断是否被中断，也可以调用静态方法<code>Thread.interrupted()</code>对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的<code>isInterrupted()</code>时依旧会返回<code>false</code>。<br> 许多声明抛出<code>InterruptedException</code>的方法（例如<code>Thread.sleep(long millis)</code>方法）这些方法在抛出<code>InterruptedException</code>之前，Java虚拟机会先将该线程的中断标识位清除，然后抛出<code>InterruptedException</code>，此时调用<code>isInterrupted()</code>方法将会返回<code>false</code>。</p></blockquote><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                System.out.println(<span class="string">"time = "</span> + System.currentTimeMillis() / <span class="number">1000</span> + <span class="string">", i = "</span> + i);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"theard1"</span>);</span><br><span class="line">    Thread theard2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">"theard2"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为 daemon 线程 并启动</span></span><br><span class="line">    theard1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    theard2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    theard1.start();</span><br><span class="line">    theard2.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程12运行3s</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中断线程</span></span><br><span class="line">    theard1.interrupt();</span><br><span class="line">    theard2.interrupt();</span><br><span class="line">    <span class="comment">//获取中断状态</span></span><br><span class="line">    System.out.println(<span class="string">"time = "</span> + System.currentTimeMillis() / <span class="number">1000</span> + <span class="string">", t1.isInterrupted() = "</span> + theard1.isInterrupted());</span><br><span class="line">    System.out.println(<span class="string">"time = "</span> + System.currentTimeMillis() / <span class="number">1000</span> + <span class="string">", t2.isInterrupted() = "</span> + theard2.isInterrupted());</span><br><span class="line">    <span class="comment">//防止 t1 t2 立即退出</span></span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">time &#x3D; 1560134045, t1.isInterrupted() &#x3D; false</span><br><span class="line">time &#x3D; 1560134045, t2.isInterrupted() &#x3D; true</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at java.lang.Thread.sleep(Thread.java:340)</span><br><span class="line">    at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)</span><br><span class="line">    at com.tcl.executors.Test.lambda$main$0(Test.java:16)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">time &#x3D; 1560134055, i &#x3D; -576615207</span><br></pre></td></tr></table></figure><p>​    根据输出结果，我们知道在线程<code>sleep</code>的时候，调用 <code>isInterrupted()</code> 会导致 <code>sleep interrupted</code> 异常，并且中断标记也被清除了。</p><p>​    已经被废弃的 <code>suspend()</code>（暂停）、<code>resume()</code>（恢复） 和 <code>stop()</code>（停止）。<br>​    废弃原因是，在调用方法之后，线程不会保证占用的资源被正常释放。</p><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    t.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    t.suspend();</span><br><span class="line">    System.out.println(<span class="string">"suspend time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    t.resume();</span><br><span class="line">    System.out.println(<span class="string">"resume time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    t.stop();</span><br><span class="line">    System.out.println(<span class="string">"stop time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">time &#x3D; 1560134529</span><br><span class="line">time &#x3D; 1560134530</span><br><span class="line">time &#x3D; 1560134531</span><br><span class="line">suspend time &#x3D; 1560134532</span><br><span class="line">resume time &#x3D; 1560134535</span><br><span class="line">time &#x3D; 1560134535</span><br><span class="line">time &#x3D; 1560134536</span><br><span class="line">time &#x3D; 1560134537</span><br><span class="line">stop time &#x3D; 1560134538</span><br></pre></td></tr></table></figure><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><h5 id="volatile和synchronized关键字"><a href="#volatile和synchronized关键字" class="headerlink" title="volatile和synchronized关键字"></a>volatile和synchronized关键字</h5><p>​    <code>volatile</code>修饰的变量，程序访问时都需要在共享内存中去读取，对它的改变也必须更新共享内存，保证了线程对变量访问的可见性。</p><p>​    <code>synchronized</code>：对于 <strong>同步块</strong> 的实现使用了<code>monitorenter</code>和<code>monitorexit</code>指令，而 <strong>同步方法</strong> 则是依靠方法修饰符上的<code>ACC_SYNCHRONIZED</code>来完成的。无论采用哪种方式，其本质是对一个对象的监视器<code>monitor</code>进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由<code>synchronized</code>所保护对象的监视器。</p><h5 id="等待-通知机制——wait和notify"><a href="#等待-通知机制——wait和notify" class="headerlink" title="等待/通知机制——wait和notify"></a>等待/通知机制——wait和notify</h5><p>​    指一个<code>线程A</code>调用了<code>对象O</code>的<code>wait()</code>方法进入等待状态，而另一个<code>线程B</code>调用了<code>对象O</code>的<code>notify()</code>或者<code>notifyAll()</code>方法，<code>线程A</code>收到通知后从<code>对象O</code>的<code>wait()</code>方法返回，进而执行后续操作。<br>​    等待：<code>wait()</code>、<code>wait(long)</code>、<code>wait(long, int)</code><br>​    通知：<code>notify()</code>、<code>notifyAll()</code></p><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t1 start object.wait(), time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">                object.wait();</span><br><span class="line">                System.out.println(<span class="string">"t1 after object.wait(), time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2 start object.notify(), time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">"t2 after object.notify(), time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(<span class="string">"t2  hold lock again, time = "</span> + System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 start object.wait(), time &#x3D; 1560138112</span><br><span class="line">t2 start object.notify(), time &#x3D; 1560138116</span><br><span class="line">t2 after object.notify(), time &#x3D; 1560138116</span><br><span class="line">t2  hold lock again, time &#x3D; 1560138116</span><br><span class="line">t1 after object.wait(), time &#x3D; 1560138116</span><br></pre></td></tr></table></figure><blockquote><p>1.使用<code>wait()</code>、<code>notify()</code>和<code>notifyAll()</code>时需要先对调用对象加锁,否则会报<code>java.lang.IllegalMonitorStateException</code>异常。<br> 2.调用<code>wait()</code>方法后，线程状态由<code>RUNNING</code>变为<code>WAITING</code>，并将当前线程放置到对象的等待队列。<br> 3.<code>notify()</code>或<code>notifyAll()</code>方法调用后，等待线程依旧不会从<code>wait()</code>返回，需要调用<code>notify()</code>或<code>notifAll()</code>的线程释放锁之后，等待线程才有机会从<code>wait()</code>返回。<br> 4.<code>notify()</code>方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而<code>notifyAll()</code>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由<code>WAITING</code>变为<code>BLOCKED</code>。<br> 5.从<code>wait()</code>方法返回的前提是获得了调用对象的锁。</p></blockquote><h5 id="等待-通知的经典范式"><a href="#等待-通知的经典范式" class="headerlink" title="等待/通知的经典范式"></a>等待/通知的经典范式</h5><p>包括 <strong>等待方</strong>（消费者）和 <strong>通知方</strong>（生产者）。<br>等待方遵循以下原则：</p><ul><li>获取对象的锁。</li><li>如果条件不满足，那么调用对象的<code>wait</code>方法，被通知后任要检查条件。</li><li>条件不满足则执行对应的逻辑。</li></ul><p>对应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知方遵循以下原则：</p><ul><li>获取对象的锁。</li><li>改变条件。</li><li>通知所有在等待在对象上的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入/输出流"></a>管道输入/输出流</h5><p><code>PipedOutputStream</code>、<code>PipedInputStream</code>、<code>PipedReader</code> 和 <code>PipedWriter</code>。<br>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> PipedWriter writer;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> PipedReader reader;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">    writer = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">    reader = <span class="keyword">new</span> PipedReader();</span><br><span class="line">    <span class="comment">//绑定输入输出</span></span><br><span class="line">    writer.connect(reader);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> ((res = reader.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">while</span> ((res = System.in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        writer.write(res);</span><br><span class="line">        <span class="comment">//按回车结束</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    writer.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hi!</span><br><span class="line"><span class="number">72</span></span><br><span class="line"><span class="number">105</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line">Hi!</span><br></pre></td></tr></table></figure><h5 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h5><p><code>thread.join()</code> 即当前线程需要在 <code>thread</code> 线程执行完之后才能继续执行，<a href="https://www.jianshu.com/p/595be9eab056" target="_blank" rel="noopener">Java Thread.join()详解</a>，这里已经做了详细介绍了，就不再赘述了。</p><hr><h5 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h5><p>​    <code>ThreadLocal</code>,即线程变量，是一个以<code>ThreadLocal</code>对象为 <strong>键</strong> 、<code>任意对象</code> 为 <strong>值</strong> 的存储结构。<br>​    这个结构被附带在线程上，也就是说一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值。<br>​    可以通过 <code>set(T t)</code> 设置， <code>get()</code> 获取。<br> 示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    String time = String.valueOf(System.currentTimeMillis() / <span class="number">1000</span>);</span><br><span class="line">    System.out.println(<span class="string">"time = "</span> + time);</span><br><span class="line">    threadLocal.set(time);</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        String time1 = String.valueOf(System.currentTimeMillis());</span><br><span class="line">        System.out.println(<span class="string">"time1 = "</span> + time1);</span><br><span class="line">        threadLocal.set(time1);</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">"threadLocal.get() = "</span> + threadLocal.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time = <span class="number">1560146178</span></span><br><span class="line">time1 = <span class="number">1560146178263</span></span><br><span class="line">threadLocal.get() = <span class="number">1560146178</span></span><br></pre></td></tr></table></figure><p>​    可以看到<code>线程t</code>中对<code>threadLocal</code>设置的值，并不影响<code>main线程</code>中的值。</p><p><code>set(T value)</code>方法的源代码：<br>    可以看到即把 <strong>当前ThreadLocal对象</strong> 为 <code>key</code>，<strong>传入的参数</strong> 为<code>value</code> 保存在 <code>ThreadLocalMap</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本文我们介绍了：</p><ul><li>什么是线程，为什么使用多线程，线程的优先级、状态变化 以及 <code>Deamon</code>线程。</li><li>线程启动<code>start()</code> 和 中断线程<code>interrupt()</code>，以及过期的<code>suspend()</code>、<code>resume()</code>、<code>stop()</code>的作用。</li><li>通过 <code>volatile</code> 来 <code>synchronized</code>来保证变量在多线程中的可见性，实现线程间通信。</li><li>用 线程的 <strong>等待/通知</strong> 机制 来 实现线程间通信，使用的注意事项 以及 <strong>等待方</strong> 和 <strong>通知方</strong> 需要遵循的原则。</li><li>通过管道输入输出流 <code>PipedOutputStream</code>、<code>PipedInputStream</code>、<code>PipedWirter</code>、<code>PipedReader</code>的介绍。</li><li>Thread.join() 的使用介绍。</li><li><code>ThreadLocal</code>的使用介绍。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Concurrency</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Concurrency</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架中表的深入理解</title>
    <link href="/2019/11/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%A1%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <url>/2019/11/26/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E8%A1%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p><code>Collections API</code>是<code>Java</code>中对于一些普通数据结构的实现，里面包含很多东西，但本片就单单对于表讲解。表ADT是在<code>Collections API</code>中实现的数据结构之一。</p></blockquote><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>​    <code>Collections API</code>位于<code>java.util</code>包中，其中存储一组类型相同的对象。<code>Collections</code>接口扩展了<code>Iterable</code>（迭代器）接口。实现<code>Iterable</code>接口的类可以拥有和for循环一样的能力去遍历集合中的所有元素。以下为<code>Collections</code>的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">AnyType</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">AnyType</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;<span class="comment">//获得集合长度</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;<span class="comment">//查看集合是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;<span class="comment">//清空该集合所有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(AnyType x)</span></span>;<span class="comment">//查看元素x是否在集合中</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(AnyType x)</span></span>;<span class="comment">//往集合中添加元素x</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(AnyType x)</span></span>;<span class="comment">//删除集合中的元素x</span></span><br><span class="line">    java.util.<span class="function">Itertor&lt;AnyType&gt; <span class="title">iterator</span><span class="params">()</span></span>;<span class="comment">//为该集合添加迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以下此例用来遍历集合并打印各个项，将任意类型的集合中所有的项打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;AnyType&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;AnyType&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(AnyType item:list)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator接口"><a href="#Iterator接口" class="headerlink" title="Iterator接口"></a>Iterator接口</h2><p>​    <code>Iterator</code>方法用以实现<code>Iterable</code>接口，该方法返回一个迭代器类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">AnyType</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;<span class="comment">//查看是否存在下一项</span></span><br><span class="line">    <span class="function">AnyType <span class="title">next</span><span class="params">()</span></span>;<span class="comment">//给出相应调用次数的该项</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//删除由next()返回的项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    <code>Iterator</code>接口的<code>remove()</code>方法值得一提，该方法可以删除由<code>next()</code>最新返回的项。<code>Iterator</code>的<code>remove()</code>方法要优于<code>Collections</code>接口中的<code>remove()</code>方法。优点在于：<code>Collections</code>的<code>remove()</code>方法必须要先找出要被删除的项。如果知道所要删除的项的位置，那么要删除的开销要小很多。如果会有接连删除的情况，那么<code>Iterator</code>的<code>remove()</code>要潜藏着更高的效率。</p><p>​    在获取相应迭代器对象是，必须先声明一个类型的迭代器对象，然后用相应集合的方法获取，实例化声明的对象。下例即为通过获取迭代器对象对集合进行遍历输出的一个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;AnyType&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Collection&lt;AnyType&gt; list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Iterator&lt;AntType&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    &#123;</span><br><span class="line">        AnyType item = iterator.next();</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    依照此迭代器对象即可轻松遍历集合中的所有元素。但也有一个须特别重要的基本法则：如果正在被迭代的集合进行结构上的改变（如<code>add()</code>,<code>remove()</code>或者<code>clear()</code>方法），那么迭代器就不再合法，并且在其后使用该迭代器时都会产生<code>ConcurrentModificationException</code>异常。这意味着，只有在立即需要使用一个迭代器的时候，再获取迭代器。但是如果使用自己的<code>remove()</code>方法改变结构，就不会报错，此迭代器依旧合法。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java Connection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat详解与运行机制</title>
    <link href="/2019/11/04/Tomcat%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2019/11/04/Tomcat%E8%AF%A6%E8%A7%A3%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述的主要是<strong>Tomcat服务器</strong>的概述和原生项目的设置运行，主要对<strong>文件和常见设置</strong>配置的详解与描述，原生项目的创建以及运行原理进行解释，尽力论述严谨，但因个人水平有限，如果有错误或者概念模糊不正确的地方，还请指正。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    <code>Tomcat</code>服务器是当今市面上性能比较稳定，技术先进，并且支持<code>JSP</code>和<code>Servlet</code>规范比较完善的一个免费<code>Web</code>应用服务器，主要由<strong><em>APACHE</em></strong>和<strong><em>SUN</em></strong>公司开发与维护，但也正是由于<strong><em>SUN</em></strong>公司的参与，才得以让<code>JSP</code>与<code>Servlet</code>在<code>Tomcat</code>中得以完整应用和体现。</p><p>​    <code>Tomcat</code>服务器是一个完全开源的轻量级<code>Web</code>应用服务器，但也由于对<code>JSP</code>和<code>Servlet</code>的支持，也吸引了很多的<code>Java</code>编辑爱好者和很多厂商的肯定，十分流行。 的也由于产品规模属于轻量级，因此在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试<code>JSP</code>程序的首选。而作为初学者而言，<code>Tomcat</code>作为很多人的选择可以说在性能上不输于大型<code>Web</code>服务器。</p><h2 id="下载配置与运行"><a href="#下载配置与运行" class="headerlink" title="下载配置与运行"></a>下载配置与运行</h2><h3 id="Tomcat下载"><a href="#Tomcat下载" class="headerlink" title="Tomcat下载"></a>Tomcat下载</h3><p>​    <code>Apache Tomcat</code>官网下载地址：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener">Apache Tomcat</a>。在下载页面有很多选项供你选择，由<code>.zip</code>文件和<code>.exe</code>文件可供选择，大部分人都选择<code>.zip</code>文件下载，因为无论什么样的机器，配置好环境变量就可以使用。</p><h3 id="Tomcat环境变量配置"><a href="#Tomcat环境变量配置" class="headerlink" title="Tomcat环境变量配置"></a>Tomcat环境变量配置</h3><p>​    下载完成之后，就要进行<code>Tomcat</code>环境变量的配置，此配置基于<code>JDK(Java Developer Kit)</code>开发者组件，必须在<code>JDK</code>环境变量的基础上进行配置，一共要创建三个环境变量，如下表所示</p><table><thead><tr><th>名称</th><th>地址</th><th>注释</th></tr></thead><tbody><tr><td>CATALINA_HOME</td><td>D:\Install\Apache TomCat</td><td>此处放上Tomcat根目录的地址</td></tr><tr><td>CATALINA_BASE</td><td>D:\Install\Apache TomCat</td><td>此处放上Tomcat根目录的地址</td></tr><tr><td>PATH</td><td>D:\Install\Apache TomCat\(bin/lib)</td><td>此处加上根目录下lib和bin的地址</td></tr></tbody></table><p>​    表格中的地址是本人电脑中的地址，读者可以根据自己的需求<strong>更改</strong>。配置好之后开启<code>bin\startup.bat</code>等待一下，显示开启成功，打开浏览器键入<a href="https://localhost:8080" target="_blank" rel="noopener">localhost:8080</a>，显示<code>Tomcat</code>表示环境变量配置成功。</p><h3 id="Tomcat根目录构成介绍"><a href="#Tomcat根目录构成介绍" class="headerlink" title="Tomcat根目录构成介绍"></a>Tomcat根目录构成介绍</h3><blockquote><p><code>bin:</code> 存放可执行文件</p><p><code>conf：</code>存放配置文件</p><p><code>lib：</code>依赖的第三方库文件</p><p><code>log：</code>存放日志文件</p><p><code>temp：</code>存放临时文件</p><p><code>webapps：</code>存放可执行的项目</p><p><code>work：</code>存放由<code>JSP</code>编译生成的文件</p><p>其余为解释说明文件</p></blockquote><p>​    <code>bin</code>目录主要存放例如<code>startup.bat</code>和<code>shutdown.bat</code>等一些可以进行服务器运行的可执行文件。<code>conf</code>目录存放像<code>server.xml</code>对服务器的配置文件，对服务器的配置更改都在这里完成。<code>lib</code>目录存放<code>Tomcat</code>的第三方依赖文件，比如基于<code>Java</code>环境的<code>JAR</code>包。<code>log</code>目录存放每一天的日志，如果运行出错，可以在日志文件中查找出错原因。<code>temp</code>主要就是存放临时文件，比如一些一次性文件。<code>webapps</code>中存放已创建的项目，而在本地服务器运行时也是默认访问<code>webapps\ROOT</code>。<code>work</code>存放的是由<code>.jsp</code>文件编译成的<code>.java</code>文件，还有由<code>.java</code>生成的<code>.class</code>文件。其余均为<code>Tomcat</code>服务器的说明文件。</p><h3 id="Tomcat服务器的运行"><a href="#Tomcat服务器的运行" class="headerlink" title="Tomcat服务器的运行"></a>Tomcat服务器的运行</h3><p>​    到这里做完前几步，算是对<code>Tomcat</code>服务器进行了配置和简单的结构了解，配置成功之后我们就可以开启服务器。打开<code>bin\startup.bat</code>服务器成功启动，打开浏览器键入<a href="https://localhost:8080" target="_blank" rel="noopener">localhost:8080</a>，此时出现<em>Tomcat</em>页面就是存放在<code>webapps</code>下的<code>ROOT</code>项目，因为这是<code>Tomcat</code>的默认路径，如果要访问其他项目，再打开浏览器输入的<code>localhost:8080</code>后面加上具体的项目名称即可，例如我要访问<code>webapps\example</code>项目，键入：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://localhost:8080/example</span></span><br></pre></td></tr></table></figure><p>​    这样就可以访问其他的项目，在后面创建的个人项目也是用这样的方法访问。</p><h3 id="常用响应状态码"><a href="#常用响应状态码" class="headerlink" title="常用响应状态码"></a>常用响应状态码</h3><ul><li><p>200：一切正常 [一般不显示的状态码，作为了解]</p></li><li><p>300/301：页面重定向 [进行页面跳转]</p></li><li><p>403：权限不足 [没有访问目标资源的条件]</p></li><li><p>404：资源不存在 [表示正在访问的文件不存在（<strong>丢失或已删除</strong>）]</p></li><li><p>500：服务器内部错误 [代码有错误]</p><p>在这里只介绍比较常用的状态码，更多的状态码需要各位动手积累经验。</p></li></ul><h3 id="创建与访问自己的项目"><a href="#创建与访问自己的项目" class="headerlink" title="创建与访问自己的项目"></a>创建与访问自己的项目</h3><p>​    前面的目录构成介绍里面讲到，所有的项目都在<code>webapps</code>文件夹下存放，现在我们就在此文件夹下创建一个自己的项目名为<code>JspProgram</code>(<em>命名随意</em>)，一个项目必须有的文件是<code>WEB-INF</code>和里面的<code>web.xml</code>，这个文件可以去别的项目下直接复制过来都可以。要注意的是，在<code>WEB-INF</code>文件夹下要与<code>web.xml</code>同级创建两个文件夹，分别命名为<code>classes</code>和<code>lib</code>，其中<code>classes</code>用来存放字节码文件，也就是由<code>.class</code>文件编译生成的<code>.java</code>和<code>.class</code>文件，<code>lib</code>中存放此项目的第三方依赖库，比如此项目需要的<code>JAR</code>包。这样就建立好了一个<code>web</code>项目的文件结构。</p><p>​    值得注意的是，此处的<code>lib</code>文件夹中存放的是支持此项目的依赖文件，而<code>Tomcat</code>根目录下的也有<code>lib</code>目录，此文件夹存放的是给所有的<code>Tomcat</code>项目支持的依赖文件，是全局与局部的关系。具体含义是，所有的<code>Tomcat</code>项目都可以访问根目录下的<code>lib</code>下的依赖文件，而本项目只能访问自己的<code>lib</code>下的依赖文件。<code>web.xml</code>中放房此项目的配置信息。</p><p>​    接下来在<code>JspProgram</code>项目文件夹下创建一个与<code>WEB-INF</code>同级的文件<code>index.jsp</code>,这个文件就是你要写入自己代码的文件，写如类似这样的程序：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;MyFirstJSP&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">hello JSP</span><br><span class="line">&lt;%</span><br><span class="line">out.print(<span class="string">"hello world!"</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>​    此代码只是为了说明<code>JSP</code>中的程序内容，故举个简单的例子。</p><p>​    写好保存之后，就可以打开服务器，输入<code>https://localhost:8080/JspProgram</code>后面的项目名根据自己的命名自行输入，输入完成按<code>Enter</code>键就可以看到上述代码所展现的内容，这就完成了一个简单的<code>JSP</code>项目，以后所有的项目都是像这样的执行流程一样去操作，就可以根据你写的不同的代码，去展现不同的页面内容。</p><p>​    其中<code>&lt;%...%&gt;</code>被叫做<code>JSP</code>脚本。</p><p>​    到这里你会发现<code>JSP</code>宏观理解就是，在<code>HTML</code>中嵌套了<code>Java</code>代码。</p><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>​    等待原生项目创建完成并且成功运行之后，如果在项目根目录下再添加一个<code>.JSP</code>文件，再次打开服务器去运行项目时，网页上展现的还是之前的<code>JSP</code>文件中你的代码运行之后的结果页面那样。这就涉及到配置文件中<code>&lt;welcome-file-list&gt;</code>设置，在<code>web.xml</code>中可以以一定的规范来规定<code>&lt;welcome-file-list&gt;</code>配置相应文件的执行顺序：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    此程序段中，规定在项目运行时，先找<code>index.html</code>文件，如果找到就运行程序，没找到就找下一个规定的文件<code>index.htm</code>，找到就运行程序，以此类推，直到找到相应文件，打开项目，或者一直都没有像配置文件中规定的那样，最后反应<code>404</code>未找到资源。</p><p>​    一般情况下，推荐使用此配置信息来指定首页，以免造成页面丢失等其他不可预料的后果。</p><h3 id="web-xml配置文件详解"><a href="#web-xml配置文件详解" class="headerlink" title="web.xml配置文件详解"></a>web.xml配置文件详解</h3><h4 id="定义头和根元素"><a href="#定义头和根元素" class="headerlink" title="定义头和根元素"></a>定义头和根元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br></pre></td></tr></table></figure><p>​    部署描述符文件就像所有的XML文件一样，必须以一个<code>XML</code>头开始。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    <code>DOCTYPE</code>声明必须立即出现在此头之后，这个生 明告诉服务器适用的<code>servlet</code>规范的版本（如2.2或2.3）并指定管理此文件其余部分内容的语法的<code>DTD</code>(Document Type Definition，文档类型定义)。 所有部署描述符文件的顶层（根）元素为<code>web-app</code>。 </p><h4 id="部署描述符文件内的元素次序"><a href="#部署描述符文件内的元素次序" class="headerlink" title="部署描述符文件内的元素次序"></a>部署描述符文件内的元素次序</h4><p>​      <code>XML</code>元素不仅是大小写敏感的，而且它们还对出现在其他元素中的次序敏感。例如，<code>XML</code>头必须是文件中的第一项，<code>DOCTYPE</code>声明必须是第二项，而<code>web-app</code>元素必须是第三项。在<code>web-app</code>元素内，元素的次序也很重要。服务器不一定强制要求这种次序，但它们允许（实际上有些服务器就是这样做的）完全拒绝执行含有次序不正确的元素的<code>Web</code>应用。这表示使用非标准元素次序的<code>web.xml</code>文件是不可移植的。 </p><p>​    下表给出合理的配置文件的合法顺序信息。例如，此列表说明<code>servlet</code>元素必须出现在所有<code>servlet-mapping</code>元素之前。值得注意的是，就算省略掉某一元素，绝对不可以把它放于不正确的位置。 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">         </span><br><span class="line">    <span class="comment">&lt;!-- icon元素指出IDE和GUI工具用来表示Web应用的一个和两个图像文件的位置。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">icon</span>&gt;</span><span class="tag">&lt;/<span class="name">icon</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- display-name元素提供GUI工具可能会用来标记这个特定的Web应用的一个名称。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span><span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- description元素给出与此有关的说明性文本。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- context-param元素声明应用范围内的初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- filter 过滤器元素将一个名字与一个实现javax.servlet.Filter接口的类相关联。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span>&gt;</span><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- filter-mapping 一旦命名了一个过滤器，就要利用filter-mapping元素把它与一个或多个servlet或JSP页面相关联。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- listener 对事件监听程序的支持，事件监听程序在建立、修改和删除会话或servlet环境时得到通知。Listener元素指出事件监听程序类。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- servlet 在向servlet或JSP页面制定初始化参数或定制URL时，必须首先命名servlet或JSP页面。Servlet元素就是用来完成此项任务的。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- servlet-mapping 服务器一般为servlet提供一个缺省的URL：http://host/webAppPrefix/servlet/ServletName。但是，常常会更改这个URL，以便servlet可以访问初始化参数或更容易地处理相对URL。在更改缺省URL时，使用servlet-mapping元素。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- session-config 如果某个会话在一定时间内未被访问，服务器可以抛弃它以节省内存。可通过使用HttpSession的setMaxInactiveInterval方法明确设置单个会话对象的超时值，或者可利用session-config元素制定缺省超时值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-config</span>&gt;</span><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- mime-mapping 如果Web应用具有想到特殊的文件，希望能保证给他们分配特定的MIME类型，则mime-mapping元素提供这种保证。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mime-mapping</span>&gt;</span><span class="tag">&lt;/<span class="name">mime-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- welcome-file-list元素指示服务器在收到引用一个目录名而不是文件名的URL时，使用哪个文件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- error-page元素使得在返回特定HTTP状态代码时，或者特定类型的异常被抛出时，能够制定将要显示的页面。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- resource-env-ref元素声明与资源相关的一个管理对象。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource-env-ref</span>&gt;</span><span class="tag">&lt;/<span class="name">resource-env-ref</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- resource-ref元素声明一个资源工厂使用的外部资源。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resource-ref</span>&gt;</span><span class="tag">&lt;/<span class="name">resource-ref</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- security-constraint元素制定应该保护的URL。它与login-config元素联合使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 用login-config元素来指定服务器应该怎样给试图访问受保护页面的用户授权。它与sercurity-constraint元素联合使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">login-config</span>&gt;</span><span class="tag">&lt;/<span class="name">login-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- security-role元素给出安全角色的一个列表，这些角色将出现在servlet元素内的security-role-ref元素的role-name子元素中。分别地声明角色可使高级IDE处理安全信息更为容易。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security-role</span>&gt;</span><span class="tag">&lt;/<span class="name">security-role</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- env-entry元素声明Web应用的环境项。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">env-entry</span>&gt;</span><span class="tag">&lt;/<span class="name">env-entry</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ejb-ref元素声明一个EJB的主目录的引用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ejb-ref</span>&gt;</span><span class="tag">&lt;/<span class="name">ejb-ref</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- ejb-local-ref元素声明一个EJB的本地主目录的应用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ejb-local-ref</span>&gt;</span><span class="tag">&lt;/<span class="name">ejb-local-ref</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="分配名称和URL"><a href="#分配名称和URL" class="headerlink" title="分配名称和URL"></a>分配名称和URL</h4><p>​    在<code>web.xml</code>中完成的一个最常见的任务是对<code>servlet</code>或<code>JSP</code>页面给出名称和定制的URL。用<code>servlet</code>元素分配名称，使用<code>servlet-mapping</code>元素将定制的<code>URL</code>与刚分配的名称相关联。 </p><p>​     为了提供初始化参数，对<code>servlet</code>或<code>JSP</code>页面定义一个定制URL或分配一个安全角色，必须首先给<code>servlet</code>或<code>JSP</code>页面一个名称。可通过<code>servlet</code>元素分配一个名称。最常见的格式包括<code>servlet-name</code>和<code>servlet-class</code>子元素</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>FullyQualifiedName<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ServletName<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>URL<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    这表示位于<code>WEB-INF/classes/FullyQualifiedName</code>的<code>servlet</code>已经得到了注册名<code>ServletName</code>。给 <code>servlet</code>一个名称具有两个主要的含义。首先，初始化参数。定制的URL模式以及其他定制通过此注册名而不是类名引用此<code>servlet</code>。其次,可在 URL而不是类名中使用此名称。 </p><p>​    对单个地<code>servlet</code>或<code>JSP</code>页面分配初始化参数。指定的<code>servlet</code>或<code>JSP</code>页面利用<code>ServletConfig</code>的<code>getInitParameter</code>方法读取这些参数。但是，在某些情形下，希望提供可由任意<code>servlet</code>或<code>JSP</code>页面借助<code>ServletContext</code>的<code>getInitParameter</code>方法读取的系统范围内的初始化参数。<br>可利用<code>context-param</code>元素声明这些系统范围内的初始化值。<code>context-param</code>元素应该包含<code>param-name</code>、<code>param-value</code>以及可选的<code>description</code>子元素。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>support-email<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>blackhole@mycompany.com<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><pre><code>为了保证可移植性，`web.xml`内的元素必须以正确的次序声明。</code></pre><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>v1.0 </p><p>Tomcat基础配置和了解</p><p><strong><em>2019.11.7</em></strong></p><p>v1.1</p><p>web.xml 的简单基础配置</p><p><strong><em>2019.11.16</em></strong></p>]]></content>
    
    
    <categories>
      
      <category>Tomcat</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tomcat</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo)</title>
    <link href="/2019/11/01/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-Github-Hexo/"/>
    <url>/2019/11/01/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99-Github-Hexo/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要讲的是<strong>个人博客的搭建</strong>，并且本文篇幅较长，主要针对新手和没有深入使用过<em>分布式管理系统</em>的人，每一步都比较<strong>详细</strong>，所以可能会显得比较啰嗦，基础较好的同志可以挑出自己喜欢的部分食用。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    本人也是在偶然的过程中接触到个人博客网页的搭建以及使用，周围也有很多人都在使用第三方的博客平台进行写作，像<code>CSDN</code>或者<code>简书</code>都是很厉害的创作平台，但也有一些人想要自己动手去自己搭建一个自由度较高，并且个性化比较高的一个博客网站。而搭建博客的成本的确是特别的高，对于大多数人来说，没有时间和精力去做这些非自己专业范畴内的东西。我也是受周围人的影响，发现了基于开源框架搭建博客，直接在<code>Github Page</code>平台上托管我们的博客。我想也有很多人想要有个属于自己的博客网站，我自己也是从一个什么都不懂的小白到现在拥有了自己的博客网站，写这篇博客的初衷一个是想帮助到也想要做博客网站的人，第二就是为自己的搭建过程做记录，方便以后维护修改。</p><p>​    本博客网站是基于<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>，<code>Hexo</code>是基于<code>Node.js</code>的静态网页生成框架，功能快速并且简单强大。<code>Hexo</code>官方也有非常具体的中文教程进行学习，对中文的支持非常友好。而在<code>Hexo</code>框架下，大家可以使用<code>Markdown</code>进行博客的编写，在网站搭建完成之后，只需要简单的几句代码就可以将所有文章都提交到代码托管平台<code>Github</code>，不需要进行其他繁复的操作，更回归于写作本身。</p><h2 id="第一部分-搭建及发布"><a href="#第一部分-搭建及发布" class="headerlink" title="第一部分 搭建及发布"></a>第一部分 搭建及发布</h2><h3 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h3><ul><li>安装<code>Git</code></li><li>安装<code>Node.js</code></li><li>安装<code>Hexo</code></li><li><code>GitHub</code>创建个人仓库</li><li>生成<code>SSH</code>添加到<code>GitHub</code></li><li>将<code>Hexo</code>部署到<code>GitHub</code></li><li>写&amp;发布文章</li><li><code>Markdwon</code>学习和工具</li></ul><h4 id="1-安装-Git"><a href="#1-安装-Git" class="headerlink" title="1.安装 Git"></a>1.安装 Git</h4><p>​    <code>Git</code>是世界上最广为应用的<strong><em>分布式版本控制系统</em></strong>，也是实用度最高的系统。可以去这里<a href="https://git-scm.com/" target="_blank" rel="noopener">下载</a>,它可以高速对项目版本进行管理。</p><p>​    <code>Windows</code>:在<code>Git</code>官网下载好<code>.exe</code>文件之后，进行安装，在最后一步直接选择<code>Use git from Windows Command Prompt</code>就可以直接在命令提示符里打开<code>Git</code>，直接右键选择<code>Git Bash</code>就可以进行命令行操作。安装完成之后在命令提示符中输入<code>git -version</code>查看是否版本验证成功。</p><h4 id="2-安装-Node-js"><a href="#2-安装-Node-js" class="headerlink" title="2.安装 Node.js"></a>2.安装 Node.js</h4><p>​    要使用<code>Hexo</code>进行博客框架搭建，就先要安装<code>Node.js</code>和里面的<code>npm</code>工具组件。</p><p>​    进入<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>下载稳定版本，安装选项全部选择默认即可，安装好之后在命令提示符中输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，表示已经成功安装工具组件。</p><h4 id="3-安装-Hexo"><a href="#3-安装-Hexo" class="headerlink" title="3.安装 Hexo"></a>3.安装 Hexo</h4><p>​    成功经过前两步，说明已经成功安装<code>Git</code>和<code>Node.js</code>，接下里就可以安装<code>Hexo</code>。</p><p>​    首先现在本地创建一个文件夹用来存放本地博客文件（比如我的本地文件夹为<code>F:\Blog</code>），直接在该文件夹下右键<code>Git Bash Here</code>打开<code>Git</code>的控制台，以后的所有操作都会在这里进行。</p><p>​    定位在该目录下，打开<code>Git</code>控制台，输入<code>npm install -g hexo-cli</code>进行安装<code>Hexo</code>，中间会弹出来几个警告或者报错，无视即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli//安装Hexo</span><br></pre></td></tr></table></figure><p>​    在安装过程中会有一些时间等待，时间长短由网速快慢决定，等待命令提示符重新可以输入则表示安装完成，输入<code>hexo -v</code>验证是否安装成功。</p><p>​    到此，Hexo静态网页生成框架安装<strong>完成</strong>！</p><p>​    接下来进行<code>Hexo</code>本地文件夹的初始化，即本地网站的初始化，<code>Git</code>命令提示符输入<code>hexo init</code>进行初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init//初始化本地文件夹</span><br><span class="line">npm install//安装必备组件</span><br></pre></td></tr></table></figure><p>​    新建初始化完成之后，指定文件夹<code>Blog</code>目录下有：</p><blockquote><p><code>node_modules:</code> 依赖包</p><p><code>public:</code> 存放生成的页面</p><p><code>scaffolds:</code> 生成文章的模板</p><p><code>source:</code> 用来存放你的文章</p><p><code>themes:</code>主题</p><p><code>_config.yml:</code> 配置文件 </p></blockquote><p>​    设置到这里，本地的网站配置已经完成，输入<code>hexo g</code>生成静态网页，再输入<code>hexo s</code>打开本地服务器，在浏览器输入打开<a href="localhost:4000">localhost:4000</a>就可以看到我们的本地博客，当然这是最初始的模板效果（按Ctrl + C关闭本地服务器）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g//生成静态网页</span><br><span class="line">hexo s//打开本地服务器</span><br><span class="line">Ctrl+C//关闭本地服务器</span><br></pre></td></tr></table></figure><h4 id="4-注册Github账号创建个人仓库"><a href="#4-注册Github账号创建个人仓库" class="headerlink" title="4.注册Github账号创建个人仓库"></a>4.注册Github账号创建个人仓库</h4><p>​    相信注册<code>GitHub</code>账号这种事情就不用多做介绍了，进入官方网站进行常规注册流程就可以完成，并且这种东西大家应该都有，就不多说了。</p><p>​    注册登录好之后，进去新建一个仓库<code>New repository</code>，仓库名字填写的时候一定注意，以<strong>你的名字</strong>开头,<code>.github.io</code>结尾。例如我的<code>Github</code>名字叫<code>jorsoe</code>，那么在填写仓库名的时候就是<code>jorsoe.github.io</code>，注意不要填写错误，这个也是之后访问你个人博客网站的入口，然后勾选上<code>README.md</code>。</p><p>​    创建完成之后可以先去设置中为自己选一个皮肤，在<code>Setting</code>选项卡里有<code>Github Pages</code>中<code>Choose a theme</code>随意选择一个来看看自己的网站是否创建成功。</p><h4 id="5-生成-SSH-添加到-GitHub"><a href="#5-生成-SSH-添加到-GitHub" class="headerlink" title="5.生成 SSH 添加到 GitHub"></a>5.生成 SSH 添加到 GitHub</h4><p>​    在本地博客文件夹中右键选择<code>Git Bash Here</code>调出命令行，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;YourGithubName&quot;&#x2F;&#x2F;双引号内填写你的GitHub用户名</span><br><span class="line">git config --global user.email &quot;YourGithubEmail&quot;&#x2F;&#x2F;双引号内填写你的Github个人邮箱</span><br></pre></td></tr></table></figure><p>​    用户名和邮箱根据你<code>Github</code>自己的信息自行更改。</p><p>​    然后输入以下命令生成<code>SSH</code>密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;YourGithubEmail&quot;&#x2F;&#x2F;双引号内填写你的Github个人邮箱</span><br></pre></td></tr></table></figure><p>​    此时你个人的<code>SSH</code>密钥就已经生成，输入以下命令将其 Copy：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub&#x2F;&#x2F;在Git命令提示符中显示出SSH密钥</span><br></pre></td></tr></table></figure><p>​    接下来打开<code>Github</code>，点击头像在选项卡中找到<code>Setting</code>设置选项，再点击<code>SSH and GPG keys</code>,新建一个<code>SSH</code>，命名随意，将刚才再<code>Git</code>输入框中复制的密钥粘贴在此处，点击保存。</p><p>​    然后回到<code>Git</code>命令行，输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com&#x2F;&#x2F;查看本地是否与Github连接成功</span><br></pre></td></tr></table></figure><p>​    如果出现自己的用户名，那就已经将本地博客与<code>Github</code>连接成功。</p><h4 id="6-将-Hexo-部署到-Github"><a href="#6-将-Hexo-部署到-Github" class="headerlink" title="6.将 Hexo 部署到 Github"></a>6.将 Hexo 部署到 Github</h4><p>​    这一步的目的是为了将<code>Hexo</code>和<code>Github</code>关联起来，关联成功之后就可以将<code>Hexo</code>生成的文章部署到<code>Github</code>上。</p><p>​    打开本地博客文件夹根目录下的<code>_config.yml</code>文件，上面说过这是博客的配置文件，如果要修改与博客配置相关的各种信息，都在此文件中。</p><p>​    将个人配置文件最后一部分修改为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/Jorsoe/Jorsoe.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>​    给<code>repository</code>仓库中填上你刚才创建的<code>Github</code>的仓库地址，<code>branch</code>分支填上主分支，保存即可。</p><h4 id="7-写-amp-发布文章"><a href="#7-写-amp-发布文章" class="headerlink" title="7.写&amp;发布文章"></a>7.写&amp;发布文章</h4><p>​     <code>npm</code>是随同<code>Node.js</code>一起安装的包管理工具，可以使用该组件来解决<code>Node.js</code>代码部署上的很多问题。 </p><p>​    在写文章之前，首先要先安装一个<code>npm</code>拓展文件，输入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-deployer-git</span><br></pre></td></tr></table></figure><p>​    等待几分钟让此拓展安装好，待命令行可以重新输入即为安装完成。</p><p>​    新建文章输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post &quot;YourNewArticalName&quot;&#x2F;&#x2F;双引号内填写你的文章名称</span><br></pre></td></tr></table></figure><p>​    然后打开你的本地博客文件夹下的<code>\source\_posts</code>目录，可以发现你刚才创建的<code>.md</code>文章文件已经创建完成，接下来就可以在<code>Markdown</code>文件中编写你的博客内容，然后根目录下输入<code>hexo g</code>生成静态网页，输入<code>hexo s</code>打开本地服务器，在<code>localhost:4000</code>中预览博客网站以及内容，最后输入<code>hexo g</code>上传到你的个人博客网站，这就完成了个人博客的写作，预览和上传。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g&#x2F;&#x2F;生成静态网页</span><br><span class="line">hexo s&#x2F;&#x2F;打开本地服务器并在localhost:4000预览</span><br><span class="line">hexo d&#x2F;&#x2F;上传到网页</span><br></pre></td></tr></table></figure><p>​    到这里，已经掌握了简单的个人博客网站的运营和文章的写作和发布，基础部分已经完成。</p><h4 id="8-Markdown学习和工具"><a href="#8-Markdown学习和工具" class="headerlink" title="8.Markdown学习和工具"></a>8.Markdown学习和工具</h4><p>​    所有的框架与工具配置好之后，就可以在<code>\source\_post</code>文件夹里面的<code>.md</code>文件进行博客的编撰，而编撰过程使用Markdown语法进行编写，点击<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">Markdown</a>进入此网站学习，教程比较全面而且讲述清晰，很容易理解。</p><p>​    工具使用<a href="https://typora.io/" target="_blank" rel="noopener">Typora</a>,一个轻量级的<code>Markdown</code>文本编辑器，界面极简并且功能强大。</p><h2 id="第二部分-个人定制"><a href="#第二部分-个人定制" class="headerlink" title="第二部分 个人定制"></a>第二部分 个人定制</h2><h3 id="1-Hexo相关"><a href="#1-Hexo相关" class="headerlink" title="1. Hexo相关"></a>1. Hexo相关</h3><h4 id="1-1-博客目录构成介绍"><a href="#1-1-博客目录构成介绍" class="headerlink" title="1.1 博客目录构成介绍"></a>1.1 博客目录构成介绍</h4><blockquote><p>node_modules：里面存放<code>Node.js</code>各种库的目录</p><p>public：生成网页的文件目录</p><p>scaffolds：存放新文章和新页面的初始设置</p><p>source：存放文章，各类页面，图想等文件</p><p>themes：存放着主题文件</p><p>_config.yml：博客配置文件</p></blockquote><h4 id="1-2-Hexo基本配置"><a href="#1-2-Hexo基本配置" class="headerlink" title="1.2 Hexo基本配置"></a>1.2 Hexo基本配置</h4><p>​    在根目录下的<code>_config.yml</code>，就是整个<code>Hexo</code>框架的配置文件，大部分的配置信息都可以在里面进行更改。详情可参考官方<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置描述</a>。</p><ul><li>title：网站标题</li><li>subtitle：网站副标题</li><li>description：网站描述</li><li>author：作者</li><li>language：语言</li><li>timezone：网站时区（默认使用电脑时区）</li></ul><h4 id="1-3-Front-Matter"><a href="#1-3-Front-Matter" class="headerlink" title="1.3 Front-Matter"></a>1.3 Front-Matter</h4><p>​    很多自己的博客都要对自己的每一篇博客加入很多参数来进行分类或者设置，这些都在你的<code>.md</code>文件的<code>Front-Matter</code>区域，<code>Front-matter</code> 是文件最上方以 <code>---</code>分隔的区域，通常有以下的设置 :</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center"><code>layout</code></td><td align="center">布局</td><td align="center"></td></tr><tr><td align="center"><code>title</code></td><td align="center">标题</td><td align="center">文章的文件名</td></tr><tr><td align="center"><code>date</code></td><td align="center">建立日期</td><td align="center">文件建立日期</td></tr><tr><td align="center"><code>updated</code></td><td align="center">更新日期</td><td align="center">文件更新日期</td></tr><tr><td align="center"><code>comments</code></td><td align="center">开启文章的评论功能</td><td align="center">true</td></tr><tr><td align="center"><code>tags</code></td><td align="center">标签（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>categories</code></td><td align="center">分类（不适用于分页）</td><td align="center"></td></tr><tr><td align="center"><code>permalink</code></td><td align="center">覆盖文章网址</td><td align="center"></td></tr><tr><td align="center"><code>keywords</code></td><td align="center">仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</td><td align="center"></td></tr></tbody></table><p>​    比如发布不同的文章有不同的分类，可以在<code>categories</code>中添加，有不同的标签，可以在<code>tags</code>中添加。比如本篇文章的<code>Front-Matter</code>为:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: 搭建自己的个人博客网站(Github+Hexo)</span><br><span class="line">author: Jorsoe</span><br><span class="line">date: 2019-11-02 23:43:01</span><br><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>Start</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>Github Pages</span><br><span class="line"><span class="bullet">- </span>Hexo</span><br></pre></td></tr></table></figure><p>​    其中<code>title</code>是文章名，<code>author</code>就是自己，<code>date</code>填自己的日期，不过一般每次在<code>hexo new post &quot;.....&quot;</code>的时候就自动生成了，<code>categories</code>就是类型，<code>tags</code>就是文章的标签。</p><h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h3><p>​    到这里基本的个人网站的运维都已经搞定的差不多了，但我们之前就说，搭建个人博客平太是为了更自由，更个性的展示，那么就要涉及到主题更换，接下来我们进行主题更换。</p><p>​    <code>Hexo</code>有自己的开源主题库，我们要做的就是去下载和配置<a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo主题</a>，进入之后选择自己喜欢的主题之后将其<code>Clone</code>（克隆）到本地，还是一样在本地博客根目录右击进入<code>Git Bash Here</code>，输入以下命令，由于我使用的是<code>fluid</code>，所以中间输入该主题的地址，空格之后加上本地要存放的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;fluid-dev&#x2F;hexo-theme-fluid themes&#x2F;fluid</span><br></pre></td></tr></table></figure><p>​    这样就可以将支持<code>Hexo</code>的主题下载到本地的<code>themes</code>文件夹了。</p><p>​    接下来就是配置主题文件，先在本地根目录下找到<code>_config.yml</code>配置文件，打开之后将主题改为你要更改的主题</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: fluid//将配置文件中的主题改为要更改的目标主题</span><br></pre></td></tr></table></figure><p>​    然后将更改后的东西部署到服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>​    等到运行成功之后，再打开你的个人博客网站，就会发现它已经悄悄地换成了你想要的样子。</p><p>​    而下载的主题也有自己的目录,打开之后是这样：</p><blockquote><p>languages：语言 [通常保存本网站支持的语言设置和支持]</p><p>layout：布局文件[通常此文件中添加或者删除一些小功能]</p><p>pages：页面文件</p><p>scripts：脚本文件 [存放一些<code>JavaScript</code>脚本文件]</p><p>sources：资源文件 [存放一些图片,特效之类的文件]</p><p>_config.yml：主题配置文件</p><p>_static_prefix.yml：静态网页参数</p></blockquote><p>​    主题的一些文本和图片更改都在配置文件中，包括很多的页面的配置。改正之后在用<code>Hexo</code>将更改后的网页，这样我们的主题更换就完成了。</p><h3 id="3-为网站增加访问量"><a href="#3-为网站增加访问量" class="headerlink" title="3.为网站增加访问量"></a>3.为网站增加访问量</h3><p>​    本人用到的是不蒜子插件，首先在<code>themes\fluid\layout\_partial\footer.ejs</code>中加入以下代码段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>​    将这段插入到<code>footer.ejs</code>文件的末尾。</p><p>​    然后打开你要添加页面的布局文件，我加入到了<code>About</code>页面，所以在<code>themes\fluid\layout\about.ejs</code>中添加相应代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span>&gt;</span>本站总访问量<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>次<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    将两个文件保存之后，进行<code>hexo g -d</code>操作和<code>hexo s</code>操作查看本地与网页是否出现要求的访问量效果，若有相应的显示则配置成功。</p><h3 id="4-评论区"><a href="#4-评论区" class="headerlink" title="4.评论区"></a>4.评论区</h3><p>​    对自己文章反馈一个好方法就是评论区，而评论去也有很多种选择，例如<code>Disqus</code>，<code>Gitalk</code>和<code>Valine</code>都是非常不错的评论插件平台，其中<code>Valine</code>也是一个对很多<code>Hexo</code>主题兼容与支持非常良好的一个平台，而本人也是使用的<code>Valine</code>去构建的一个文章评论区。</p><p>​    接下来讲的都是基于<code>Valine</code>的步骤，不过几乎全部的主题都是支持的。</p><p>​    <code>Valine</code>是一个轻量级评论系统，使用非常的便捷，本人也是试验了很多例如<code>Gitalk</code>或者<code>Disqus</code>这样反应很好的评论插件之后，最后选择<code>Valine</code>。那接下来开始部署<code>Valine</code>，首先进入<code>Valine</code>的官方网站<a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a>进入<strong><em>快速开始</em></strong>，在<code>leancloud</code>中注册一个个人账号，进入之后创建一个个人应用，<code>leancloud</code>支持免费开发版使用，在创建好自己的个人应用之后，在应用的设置界面，选择<code>应用Keys</code>，可以看到自己的<code>AppID</code>和<code>AppKey</code>，打开自己主题的配置文件<code>_config.yml</code>，然后将其填入,有如下片段：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># More info available at https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="comment"># your leancloud application appid</span></span><br><span class="line">  <span class="attr">appkey:</span>  <span class="comment"># your leancloud application appkey</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier, See: https://github.com/xCss/Valine/wiki</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line">  <span class="attr">placeholder:</span> <span class="string">说点什么</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">retro</span> <span class="comment"># gravatar style https://valine.js.org/avatar.html</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure><p>​    填好之后保存，然后在根目录下启动<code>Git</code>命令行，依次输入以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install leancloud-storage --save&#x2F;&#x2F;安装&#96;leadcloud&#96;集成环境</span><br><span class="line">npm install valine --save&#x2F;&#x2F;安装&#96;Valine&#96;后端评论系统</span><br></pre></td></tr></table></figure><p>​    安装好之后，保存生成静态网页就可以在文章尾部看到评论区了。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>​    本人也是看了网上的很多资料，试了很多方法，其中有成功也有失败，但也总结了很多经验，才写出了这篇文章，只要按照步骤一步一不走，一定可以做出自己的博客网站，其中也有很多不对的地方，欢迎同志们指正，后面再有更多的功能更新，本人会持续更新本篇博客。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li><p>v1.0 </p><p>个人博客的搭建以及发布，利用<code>Github</code>+<code>Hexo</code>搭建；</p><p>改正<code>hexo g</code>和<code>hexo d</code>的功能阐述错误</p><p><strong><em>2019.11.1中午</em></strong></p></li><li><p>v1.1</p><p>增加对<code>Hexo</code>个人定制部分以及主题的更改</p><p><strong><em>2019.11.2 晚上</em></strong></p></li><li><p>v1.2</p><p>增加搭建与发布模块中最后的<code>Markdown</code>语言的学习和工具</p><p><strong><em>2019.11.3上午</em></strong></p></li><li><p>v1.3</p><p>为博客网站增加总访问量，在关于页面</p><p><strong><em>2019.11.3下午</em></strong></p></li><li><p>v1.4</p><p>为博客文章页尾部加入评论系统</p><p>查看更多反馈</p><p><strong><em>2019.11.6中午</em></strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Start</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Github Pages</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
